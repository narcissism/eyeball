<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Eyeball</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #111;
}
canvas { display:block; }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let w, h;
function resize(){
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ---------- MOUSE ---------- */
let mouse = { x: w/2, y: h/2 };
window.addEventListener("mousemove", e=>{
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

/* ---------- TIME ---------- */
let startTime = performance.now();
let time = 0;

/* ---------- EYE ---------- */
const eye = {
  radius: 120,
  irisRadius: 45,
  pupilRadius: 18,
  minPupil: 10,
  maxPupil: 28,
  rotX: 0,
  rotY: 0
};

/* ---------- VEINS ---------- */
const vessels = Array.from({length:28}, ()=>({
  baseAngle: Math.random() * Math.PI * 2,
  length: 40 + Math.random() * 60,
  wiggle: Math.random() * 0.5 + 0.2,
  phase: Math.random() * Math.PI * 2
}));

/* ---------- TEARS ---------- */
const tears = [];
let puddleHeight = 0;

/* ---------- DRAW ---------- */
function draw(){
  ctx.clearRect(0,0,w,h);
  time += 0.02;

  const cx = w/2;
  const cy = h/2;

  /* ---------- LOOK ROTATION ---------- */
  const dx = mouse.x - cx;
  const dy = mouse.y - cy;

  const tx = Math.max(-1, Math.min(1, dx / 260));
  const ty = Math.max(-1, Math.min(1, dy / 260));

  eye.rotX += (tx - eye.rotX) * 0.07;
  eye.rotY += (ty - eye.rotY) * 0.07;

  /* ---------- PUPIL DILATION ---------- */
  const dist = Math.hypot(dx, dy);
  const norm = Math.min(dist / 420, 1);
  const targetPupil =
    eye.maxPupil - norm * (eye.maxPupil - eye.minPupil);
  eye.pupilRadius += (targetPupil - eye.pupilRadius) * 0.08;

  ctx.save();
  ctx.translate(cx, cy);

  /* ---------- SPHERE ---------- */
  const lightX = -eye.rotX * eye.radius * 0.45;
  const lightY = -eye.rotY * eye.radius * 0.45;

  const scleraGrad = ctx.createRadialGradient(
    lightX, lightY, eye.radius * 0.2,
    0,0, eye.radius
  );
  scleraGrad.addColorStop(0,"#fff");
  scleraGrad.addColorStop(1,"#d6d6d6");

  ctx.fillStyle = scleraGrad;
  ctx.beginPath();
  ctx.arc(0,0,eye.radius,0,Math.PI*2);
  ctx.fill();

  /* ---------- VEINS ---------- */
  vessels.forEach(v=>{
    v.phase += 0.015;
    const pulse = Math.sin(v.phase + time) * 0.35 + 1;

    ctx.strokeStyle = `rgba(170,60,60,${0.2 * pulse})`;
    ctx.lineWidth = pulse;

    let a = v.baseAngle + eye.rotX * 1.2;
    let r = eye.radius * 0.9;

    ctx.beginPath();
    ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r);
    for(let i=0;i<6;i++){
      r -= (v.length * pulse) / 6;
      a += Math.sin(i + eye.rotY * 4) * v.wiggle;
      ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    ctx.stroke();
  });

  /* ---------- SPHERICAL IRIS ROLL ---------- */
  const maxRoll = eye.radius - eye.irisRadius - 6;
  const rollX = eye.rotX * maxRoll;
  const rollY = eye.rotY * maxRoll;
  const rollDist = Math.hypot(rollX, rollY);
  const rollNorm = Math.min(rollDist / maxRoll, 1);

  const visibleIrisRadius =
    eye.irisRadius * (1 - rollNorm * 0.18);

  /* ---------- IRIS TEXTURE ---------- */
  ctx.save();
  ctx.translate(rollX, rollY);

  const irisGrad = ctx.createRadialGradient(
    -10, -10, 6,
    0,0, visibleIrisRadius
  );
  irisGrad.addColorStop(0,"#3a2715");
  irisGrad.addColorStop(0.45,"#6e4c2b");
  irisGrad.addColorStop(0.8,"#9c7a3c");
  irisGrad.addColorStop(1,"#1c1208");

  ctx.fillStyle = irisGrad;
  ctx.beginPath();
  ctx.arc(0,0,visibleIrisRadius,0,Math.PI*2);
  ctx.fill();

  /* Iris fibers (rotating subtly) */
  ctx.strokeStyle = "rgba(0,0,0,0.25)";
  const fiberSpin = time * 0.15 + eye.rotX * 0.6;
  for(let i=0;i<60;i++){
    const a = (i/60)*Math.PI*2 + fiberSpin;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a)*6, Math.sin(a)*6);
    ctx.lineTo(
      Math.cos(a)*visibleIrisRadius,
      Math.sin(a)*visibleIrisRadius
    );
    ctx.stroke();
  }

  /* Edge darkening (spherical cue) */
  ctx.fillStyle = `rgba(0,0,0,${rollNorm * 0.28})`;
  ctx.beginPath();
  ctx.arc(0,0,visibleIrisRadius,0,Math.PI*2);
  ctx.fill();

  /* ---------- PUPIL ---------- */
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(0,0,eye.pupilRadius * (1 - rollNorm * 0.15),0,Math.PI*2);
  ctx.fill();

  ctx.restore();

  /* ---------- HIGHLIGHT ---------- */
  ctx.fillStyle = "rgba(255,255,255,0.6)";
  ctx.beginPath();
  ctx.arc(lightX - 15, lightY - 15, 14, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();

  /* ---------- TEARS ---------- */
  const elapsed = (performance.now() - startTime) / 1000;

  if(elapsed > 15 && Math.random() < 0.008){
    tears.push({
      x: cx + eye.rotX * 40 + (Math.random()-0.5)*10,
      y: cy + eye.radius * 0.9,
      vy: 0.05,
      r: 6 + Math.random() * 3,
      attached: true
    });
  }

  ctx.fillStyle = "rgba(180,220,255,0.65)";
  tears.forEach(t=>{
    if(t.attached){
      t.y += t.vy;
      if(t.y > cy + eye.radius + 8){
        t.attached = false;
        t.vy = 0.25;
      }
    } else {
      t.y += t.vy;
      t.vy += 0.01;
      if(t.y > h - puddleHeight - 6){
        puddleHeight += 0.015;
        t.y = h - puddleHeight - 6;
      }
    }

    ctx.beginPath();
    ctx.ellipse(t.x, t.y, t.r, t.r * 1.4, 0, 0, Math.PI*2);
    ctx.fill();
  });

  /* ---------- PUDDLE ---------- */
  if(puddleHeight > 0){
    ctx.fillStyle = "rgba(140,180,220,0.4)";
    ctx.fillRect(0, h - puddleHeight, w, puddleHeight);
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
