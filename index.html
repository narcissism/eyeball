<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Eyeball</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #111;
}
canvas { display:block; }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let w, h;
function resize(){
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ---------- MOUSE ---------- */
let mouse = { x: w/2, y: h/2 };
window.addEventListener("mousemove", e=>{
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

/* ---------- TIME ---------- */
let startTime = performance.now();
let time = 0;

/* ---------- EYE ---------- */
const eye = {
  radius: 120,
  irisRadius: 45,
  pupilRadius: 18,
  minPupil: 10,
  maxPupil: 28,
  rotX: 0,
  rotY: 0
};

/* ---------- VEINS ---------- */
const vessels = Array.from({length:28}, ()=>({
  baseAngle: Math.random() * Math.PI * 2,
  length: 40 + Math.random() * 60,
  wiggle: Math.random() * 0.5 + 0.2,
  phase: Math.random() * Math.PI * 2
}));

/* ---------- TEARS ---------- */
const tears = [];
const streaks = [];
let puddleHeight = 0;

/* ---------- DRAW ---------- */
function draw(){
  ctx.clearRect(0,0,w,h);
  time += 0.02;

  const cx = w/2;
  const cy = h/2;

  /* ---------- LOOK ROTATION ---------- */
  const dx = mouse.x - cx;
  const dy = mouse.y - cy;

  const tx = Math.max(-1, Math.min(1, dx / 300));
  const ty = Math.max(-1, Math.min(1, dy / 300));

  eye.rotX += (tx - eye.rotX) * 0.08;
  eye.rotY += (ty - eye.rotY) * 0.08;

  /* ---------- PUPIL DILATION ---------- */
  const dist = Math.hypot(dx, dy);
  const norm = Math.min(dist / 400, 1);
  const targetPupil =
    eye.maxPupil - norm * (eye.maxPupil - eye.minPupil);
  eye.pupilRadius += (targetPupil - eye.pupilRadius) * 0.08;

  ctx.save();
  ctx.translate(cx, cy);

  /* ---------- SPHERE ---------- */
  const lightX = -eye.rotX * eye.radius * 0.4;
  const lightY = -eye.rotY * eye.radius * 0.4;

  const scleraGrad = ctx.createRadialGradient(
    lightX, lightY, eye.radius * 0.2,
    0,0, eye.radius
  );
  scleraGrad.addColorStop(0,"#fff");
  scleraGrad.addColorStop(1,"#d6d6d6");

  ctx.fillStyle = scleraGrad;
  ctx.beginPath();
  ctx.arc(0,0,eye.radius,0,Math.PI*2);
  ctx.fill();

  /* ---------- VEINS (PULSE) ---------- */
  vessels.forEach(v=>{
    v.phase += 0.015;
    const pulse = Math.sin(v.phase + time) * 0.4 + 1;

    ctx.strokeStyle = `rgba(170,60,60,${0.22 * pulse})`;
    ctx.lineWidth = pulse;

    let a = v.baseAngle + eye.rotX * 1.2;
    let r = eye.radius * 0.9;

    ctx.beginPath();
    ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r);
    for(let i=0;i<6;i++){
      r -= (v.length * pulse) / 6;
      a += Math.sin(i + eye.rotY * 4) * v.wiggle;
      ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
    }
    ctx.stroke();
  });

  /* ---------- SPHERICAL IRIS ROLL ---------- */
  const rollX = eye.rotX * 30;
  const rollY = eye.rotY * 30;
  const rollDist = Math.hypot(rollX, rollY);
  const rollNorm = Math.min(rollDist / (eye.radius * 0.55), 1);

  const visibleIrisRadius =
    eye.irisRadius * (1 - rollNorm * 0.25);

  const irisGrad = ctx.createRadialGradient(
    rollX - 8, rollY - 8, 6,
    rollX, rollY, visibleIrisRadius
  );
  irisGrad.addColorStop(0,"#3b2a14");
  irisGrad.addColorStop(0.45,"#6f4e2c");
  irisGrad.addColorStop(0.8,"#9b7b3c");
  irisGrad.addColorStop(1,"#1d1208");

  ctx.fillStyle = irisGrad;
  ctx.beginPath();
  ctx.arc(rollX, rollY, visibleIrisRadius, 0, Math.PI*2);
  ctx.fill();

  /* Iris shadow (occlusion cue) */
  ctx.fillStyle = `rgba(0,0,0,${rollNorm * 0.25})`;
  ctx.beginPath();
  ctx.arc(rollX, rollY, visibleIrisRadius, 0, Math.PI*2);
  ctx.fill();

  /* ---------- PUPIL ---------- */
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(rollX, rollY, eye.pupilRadius * (1 - rollNorm * 0.2), 0, Math.PI*2);
  ctx.fill();

  /* ---------- HIGHLIGHT ---------- */
  ctx.fillStyle = "rgba(255,255,255,0.6)";
  ctx.beginPath();
  ctx.arc(lightX - 15, lightY - 15, 14, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();

  /* ---------- TEARS ---------- */
  const elapsed = (performance.now() - startTime) / 1000;

  if(elapsed > 15 && Math.random() < 0.02){
    tears.push({
      x: cx + eye.rotX * 35 + (Math.random()-0.5)*10,
      y: cy + eye.radius * 0.95,
      vy: 0.3,
      life: 1
    });
  }

  ctx.strokeStyle = "rgba(180,220,255,0.35)";
  ctx.lineWidth = 2;

  tears.forEach(t=>{
    t.y += t.vy;
    t.vy += 0.015;
    t.life -= 0.002;

    streaks.push({
      x: t.x,
      y1: t.y - 12,
      y2: t.y
    });

    if(t.y > h - puddleHeight - 5){
      puddleHeight += 0.03;
      t.life = 0;
    }
  });

  tears.filter(t=>t.life>0);

  streaks.forEach(s=>{
    ctx.beginPath();
    ctx.moveTo(s.x, s.y1);
    ctx.lineTo(s.x, s.y2);
    ctx.stroke();
  });

  /* ---------- PUDDLE ---------- */
  if(puddleHeight > 0){
    ctx.fillStyle = "rgba(140,180,220,0.45)";
    ctx.fillRect(0, h - puddleHeight, w, puddleHeight);
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
